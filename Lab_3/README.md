# Отчет по лабораторной работе №3

## Ход работы

<details>
  <summary style="font-size: 23px;">Часть 1. Поднимаем Postgres</summary>
  <p style="font-size: 14px;">

1. Установили Docker, Docker Compose на ВМ: 

    ![lab3_1.png](images%2Flab3_1.png)

2. Перешли в рабочую директорию lab_3 и создали в ней файлы Docker, docker-compose.yml:

    ![lab3_2.png](images%2Flab3_2.png)

3. Создаем postgres0.yml и затем на основе него — postgres1.yml (надо будешь лишь поменять имя, адреса и место хранения данных ноды с первой на вторую):

    ![lab3_3.png](images%2Flab3_3.png)

4. Деплоим (docker-compose up -d). Проверяем, что контейнеры подняты:

    ![lab3_4.png](images%2Flab3_4.png)

5. Проверяем в логах, что зукипер запустился, и что одна нода постгреса из двух стала лидером/овнером/мастером используя команды:
    - docker logs pg-master
    - docker logs pg-slave
    - docker logs zoo

    ![lab3_5.png](images%2Flab3_5.png)

    ![lab3_6.png](images%2Flab3_6.png)

    ![lab3_7.png](images%2Flab3_7.png)

</p>
</details>

<details>
  <summary style="font-size: 23px;">Часть 2. Проверяем репликацию</summary>
  <p style="font-size: 14px;">

1. Подключение к postgres0:

    ```shell
    psql -h 127.0.0.1 -p 5433 -U postgres -d postgres
    ```
   
    Подключение к postgres1 (использовали другой терминал):

    ```shell
    psql -h 127.0.0.1 -p 5434 -U postgres -d postgres
    ```

2. Создание таблицы и вставка данных в мастер ноде (postgres1):

    ![lab3_8.png](images%2Flab3_8.png)

3. Доступность для чтения данных из мастер ноды в слейв ноде:

    ![lab3_9.png](images%2Flab3_9.png)

4. Попытка вставить данные в нашу таблицы запросом из слейв ноды:

    ![lab3_10.png](images%2Flab3_10.png)

</p>
</details>

<details>
  <summary style="font-size: 23px;">Часть 3. Делаем высокую доступность</summary>
  <p style="font-size: 14px;">

1. Добавил HAProxy в docker-compose.yml и создали haproxy.cfg

2. Перезапустил проект:
   ```shell
   docker-compose down
   docker-compose up -d
   ```

3. Проанализировали логи:
    
    - pg-master (реплика):
        ![lab3_11.png](images%2Flab3_11.png)

    - pg-slave (мастер):
        ![lab3_12.png](images%2Flab3_12.png)

    - zoo:
        ![lab3_13.png](images%2Flab3_13.png)

    - haproxy (postgres_entrypoint):
        ![lab3_14.png](images%2Flab3_14.png)

4. Подключились к базе через HAProxy:
    ```shell
    psql -h 127.0.0.1 -p 5432 -U postgres -d postgres
    ```
   
    ![lab3_15.png](images%2Flab3_15.png)

    С помощью SQL-запроса
    ```shell
    SELECT pg_is_in_recovery();
    ```
   я проверил, что подключен к мастер-ноде, так как запрос вернул false, что означает, что нода, к которой было выполнено подключение не находится в режиме восстановления и является мастером


</p>
</details>

<details>
  <summary style="font-size: 23px;">Задание</summary>
  <p style="font-size: 14px;">

Любым способом выключаем доступ до ноды, которая сейчас является мастером (например, через docker stop). Некоторое время ждем, после этого анализируем логи и так же пытаемся считать/записать что-то в БД через entrypoint подключение. Затем необходимо расписать, получилось или нет, а так же объяснить, что в итоге произошло после принудительного выключения мастера (со скриншотами)

- Выключаем мастер ноду pg-slave:
   ```shell
   docker stop pg-slave
   ```

- Проанализируем логи:
   
    pg-master (реплика, которая заменит мастер ноду):
    
    ![lab3_16.png](images%2Flab3_16.png)

    HAProxy:

    ![lab3_17.png](images%2Flab3_17.png)

- Подключимся к базе данных через HAProxy:
    
    ![lab3_18.png](images%2Flab3_18.png)

- Выводы: после отключения мастера pg-slave Patroni, HAProxy перенастроились и по сути сделали из реплики (pg-master) новый мастер, который полноценно заменил pg-slave. Получается система успешно справилась с отказом матсер-ноды.

</p>
</details>

<details>
  <summary style="font-size: 23px;">Доп. вопросы</summary>
  <p style="font-size: 14px;">

1. Порты 8008 и 5432 вынесены в разные директивы, expose и ports. По сути, если записать 8008 в ports, то он тоже станет exposed. В чем разница?

    **Ответ:** 

    **expose:** просто объявляет, что контейнер использует данный порт внутри своей сети. Она не делает порт доступным извне контейнера. Она полезна для того, чтобы другие контейнеры в той же сети могли связаться с этим контейнером по указанному порту. Она не публикует порт на хосте.

    **ports:** публикует порт из контейнера на хосте. Она создает сопоставление между портом на хосте и портом в контейнере. Это позволяет внешним приложениям и пользователям подключаться к контейнеру по указанному порту на хосте.

2. При обычном перезапуске композ-проекта, будет ли сбилден заново образ? А если предварительно отредактировать файлы postgresX.yml? А если содержимое самого Dockerfile? Почему?

    **Ответ:** 

    Поведение Docker Compose при перезапуске проекта относительно пересборки образов зависит от нескольких факторов:

    - **Обычный перезапуск:**
    
       При обычном перезапуске (docker-compose up -d или docker-compose restart) Docker Compose не будет пересобирать образы, если они уже существуют и не были изменены.

    - **Редактирование postgresX.yml:**
    
       Редактирование файла postgresX.yml не приведет к пересборке образа. Файл yml используется для настройки контейнера, а не для построения образа. Изменения в нем повлияют только на запуск и конфигурацию контейнера, не на сам образ.
    
    - **Редактирование Dockerfile:**
    
       Редактирование Dockerfile приведет к пересборке образа при следующем запуске docker-compose up -d. Docker Compose обнаружит изменения в Dockerfile и запустит процесс сборки заново, создавая новый образ с измененными параметрами.


</p>
</details>
